From 1e9f1a5bcd04784ddb5ad110881d12adeb3e9b28 Mon Sep 17 00:00:00 2001
From: Patrick Rudolph <patrick.rudolph@9elements.com>
Date: Sat, 29 Apr 2023 09:53:30 +0200
Subject: [PATCH 09/11] Add support to unload drivers

Overlay: Remove installed drivers when probe is false

When the FRU device is gone the probe condition is no longer true.
In that case unload the installed drivers to make sure they won't
missbehave. As with all ungraceful removals there is a chance that
the driver or other services missbehave in the meantime.

Tested: The entity-manager config was updated to expose 24C01 EEPROMs
        when the probe condition matches. When the probe condition is
        no longer true the eeprom driver is unloaded as it's no longer
        functional. As the EEPROMs do not have an IPMI FRU format they
        cannot be detected using FruDevice.

Change-Id: If78cfcaf71b8708e86c045f93271a2c8a8c5e8ec
Signed-off-by: Patrick Rudolph <patrick.rudolph@9elements.com>
Signed-off-by: Chris Cain <cjcain@us.ibm.com>
---
 src/entity_manager.cpp |  1 +
 src/overlay.cpp        | 95 +++++++++++++++++++++++++++++++++++-------
 src/overlay.hpp        |  1 +
 3 files changed, 82 insertions(+), 15 deletions(-)

diff --git a/src/entity_manager.cpp b/src/entity_manager.cpp
index db1dfb8..560345d 100644
--- a/src/entity_manager.cpp
+++ b/src/entity_manager.cpp
@@ -986,6 +986,7 @@ static void pruneConfiguration(nlohmann::json& systemConfiguration,
     ifaces.clear();
     systemConfiguration.erase(name);
     topology.remove(device["Name"].get<std::string>());
+    unloadOverlay(device);
     logDeviceRemoved(device);
 }
 
diff --git a/src/overlay.cpp b/src/overlay.cpp
index 3810c31..2aab100 100644
--- a/src/overlay.cpp
+++ b/src/overlay.cpp
@@ -69,8 +69,9 @@ static std::string deviceDirName(uint64_t bus, uint64_t address)
     return name.str();
 }
 
-void linkMux(const std::string& muxName, uint64_t busIndex, uint64_t address,
-             const nlohmann::json::array_t& channelNames)
+void linkOrUnlinkMux(const std::string& muxName, uint64_t busIndex, uint64_t address,
+                     const nlohmann::json::array_t& channelNames,
+                     const bool create)
 {
     std::error_code ec;
     std::filesystem::path muxSymlinkDirPath(muxSymlinkDir);
@@ -110,11 +111,19 @@ void linkMux(const std::string& muxName, uint64_t busIndex, uint64_t address,
         std::filesystem::path fp("/dev" / bus.filename());
         std::filesystem::path link(linkDir / *channelName);
 
-        std::filesystem::create_symlink(fp, link, ec);
-        if (ec)
-        {
-            std::cerr << "Failure creating symlink for " << fp << " to " << link
-                      << "\n";
+        if (create) {
+            std::filesystem::create_symlink(fp, link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure creating symlink for " << fp << " to " << link
+                          << "\n";
+            }
+        } else {
+            std::filesystem::remove(link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure deleteting symlink for "<< link << "\n";
+            }
         }
     }
 }
@@ -214,9 +223,10 @@ static int buildDevice(const std::string& busPath,
     return 0;
 }
 
-void exportDevice(const std::string& type,
+void exportOrRemoveDevice(const std::string& type,
                   const devices::ExportTemplate& exportTemplate,
-                  const nlohmann::json& configuration)
+                  const nlohmann::json& configuration,
+                  const bool expose)
 {
     std::string parameters = exportTemplate.parameters;
     std::string busPath = exportTemplate.busPath;
@@ -270,13 +280,21 @@ void exportDevice(const std::string& type,
         return;
     }
 
-    int err = buildDevice(busPath, parameters, *bus, *address, constructor,
+    if (expose) {
+        int err = buildDevice(busPath, parameters, *bus, *address, constructor,
                           destructor, hasHWMonDir);
-
-    if ((err == 0) && boost::ends_with(type, "Mux") && (channels != nullptr))
-    {
-        linkMux(name, *bus, *address, *channels);
+        if ((err == 0) && boost::ends_with(type, "Mux") && (channels != nullptr))
+        {
+            linkOrUnlinkMux(name, *bus, *address, *channels, true);
+        }
+    } else {
+        if (boost::ends_with(type, "Mux") && (channels != nullptr))
+        {
+            linkOrUnlinkMux(name, *bus, *address, *channels, false);
+        }
+        deleteDevice(busPath, *address, destructor);
     }
+
 }
 
 bool loadOverlays(const nlohmann::json& systemConfiguration)
@@ -310,7 +328,7 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
             auto device = devices::exportTemplates.find(type.c_str());
             if (device != devices::exportTemplates.end())
             {
-                exportDevice(type, device->second, configuration);
+                exportOrRemoveDevice(type, device->second, configuration, true);
                 continue;
             }
 
@@ -328,3 +346,50 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
 
     return true;
 }
+
+void unloadOverlay(const nlohmann::json& entity)
+{
+    std::filesystem::create_directory(outputDir);
+
+    auto findExposes = entity.find("Exposes");
+    if (findExposes == entity.end() ||
+        findExposes->type() != nlohmann::json::value_t::array)
+    {
+        return;
+    }
+
+    for (auto& configuration : *findExposes)
+    {
+        auto findStatus = configuration.find("Status");
+        // status missing is assumed to be 'okay'
+        if (findStatus != configuration.end() && *findStatus == "disabled")
+        {
+            continue;
+        }
+        auto findType = configuration.find("Type");
+        if (findType == configuration.end() ||
+            findType->type() != nlohmann::json::value_t::string)
+        {
+            continue;
+        }
+        std::string type = findType.value().get<std::string>();
+        auto device = devices::exportTemplates.find(type.c_str());
+        if (device != devices::exportTemplates.end())
+        {
+            exportOrRemoveDevice(type, device->second, configuration, false);
+            continue;
+        }
+
+        // Because many devices are intentionally not exportable,
+        // this error message is not printed in all situations.
+        // If wondering why your device not appearing, add your type to
+        // the exportTemplates array in the devices.hpp file.
+        if constexpr (debug)
+        {
+            std::cerr << "Device type " << type
+                      << " not found in export map whitelist\n";
+        }
+    }
+
+    return;
+}
diff --git a/src/overlay.hpp b/src/overlay.hpp
index 8e818c2..343ee01 100644
--- a/src/overlay.hpp
+++ b/src/overlay.hpp
@@ -20,3 +20,4 @@
 
 void unloadAllOverlays(void);
 bool loadOverlays(const nlohmann::json& systemConfiguration);
+void unloadOverlay(const nlohmann::json& entity);
-- 
2.41.0

