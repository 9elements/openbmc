From c1ff0f7df6f09e8955de4276ca75f09a3daa8831 Mon Sep 17 00:00:00 2001
From: Patrick Rudolph <patrick.rudolph@9elements.com>
Date: Sat, 29 Apr 2023 09:53:30 +0200
Subject: [PATCH 11/13] Overlay: Remove installed drivers when probe is false

When the FRU device is gone the probe condition is no longer true.
On a mainboard there might be devices that are only accessible under
certain conditions, which change during the normal operation.

An example would be memory DIMMs that can only be read when the
x86 host power is off, due to PECI accessing the DIMMs when on.

Another example would be Intel XEON PIROM that can only be read when
the x86 host is powered on.

The probe condition thus not only changes on presence change, but
also on host power update.

In that case unload the installed drivers to make sure they won't
missbehave. As with all ungraceful removals there is a chance that
the driver or other services missbehave in the meantime.

Tested: The entity-manager config was updated to expose 24C01 EEPROMs
        when the probe condition matches. When the probe condition is
        no longer true the eeprom driver is unloaded as it's no longer
        functional. As the EEPROMs do not have an IPMI FRU format they
        cannot be detected using FruDevice.

Change-Id: If78cfcaf71b8708e86c045f93271a2c8a8c5e8ec
Signed-off-by: Patrick Rudolph <patrick.rudolph@9elements.com>
Signed-off-by: Chris Cain <cjcain@us.ibm.com>
---
 src/entity_manager.cpp |  1 +
 src/overlay.cpp        | 95 +++++++++++++++++++++++++++++++++++-------
 src/overlay.hpp        |  1 +
 3 files changed, 82 insertions(+), 15 deletions(-)

diff --git a/src/entity_manager.cpp b/src/entity_manager.cpp
index 6a4580d..5a6b858 100644
--- a/src/entity_manager.cpp
+++ b/src/entity_manager.cpp
@@ -986,6 +986,7 @@ static void pruneConfiguration(nlohmann::json& systemConfiguration,
     ifaces.clear();
     systemConfiguration.erase(name);
     topology.remove(device["Name"].get<std::string>());
+    unloadOverlay(device);
     logDeviceRemoved(device);
 }
 
diff --git a/src/overlay.cpp b/src/overlay.cpp
index 3810c31..52e389e 100644
--- a/src/overlay.cpp
+++ b/src/overlay.cpp
@@ -69,8 +69,10 @@ static std::string deviceDirName(uint64_t bus, uint64_t address)
     return name.str();
 }
 
-void linkMux(const std::string& muxName, uint64_t busIndex, uint64_t address,
-             const nlohmann::json::array_t& channelNames)
+void linkOrUnlinkMux(const std::string& muxName, uint64_t busIndex,
+                     uint64_t address,
+                     const nlohmann::json::array_t& channelNames,
+                     const bool create)
 {
     std::error_code ec;
     std::filesystem::path muxSymlinkDirPath(muxSymlinkDir);
@@ -110,11 +112,22 @@ void linkMux(const std::string& muxName, uint64_t busIndex, uint64_t address,
         std::filesystem::path fp("/dev" / bus.filename());
         std::filesystem::path link(linkDir / *channelName);
 
-        std::filesystem::create_symlink(fp, link, ec);
-        if (ec)
+        if (create)
         {
-            std::cerr << "Failure creating symlink for " << fp << " to " << link
-                      << "\n";
+            std::filesystem::create_symlink(fp, link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure creating symlink for " << fp << " to "
+                          << link << "\n";
+            }
+        }
+        else
+        {
+            std::filesystem::remove(link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure deleteting symlink for " << link << "\n";
+            }
         }
     }
 }
@@ -214,9 +227,10 @@ static int buildDevice(const std::string& busPath,
     return 0;
 }
 
-void exportDevice(const std::string& type,
-                  const devices::ExportTemplate& exportTemplate,
-                  const nlohmann::json& configuration)
+void exportOrRemoveDevice(const std::string& type,
+                          const devices::ExportTemplate& exportTemplate,
+                          const nlohmann::json& configuration,
+                          const bool expose)
 {
     std::string parameters = exportTemplate.parameters;
     std::string busPath = exportTemplate.busPath;
@@ -270,12 +284,18 @@ void exportDevice(const std::string& type,
         return;
     }
 
-    int err = buildDevice(busPath, parameters, *bus, *address, constructor,
-                          destructor, hasHWMonDir);
-
-    if ((err == 0) && boost::ends_with(type, "Mux") && (channels != nullptr))
+    if (expose)
     {
-        linkMux(name, *bus, *address, *channels);
+        int err = buildDevice(busPath, parameters, *bus, *address, constructor,
+                              destructor, hasHWMonDir);
+        if (err != 0)
+        {
+            return;
+        }
+    }
+    if (boost::ends_with(type, "Mux") && (channels != nullptr))
+    {
+        linkOrUnlinkMux(name, *bus, *address, *channels, expose);
     }
 }
 
@@ -310,7 +330,7 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
             auto device = devices::exportTemplates.find(type.c_str());
             if (device != devices::exportTemplates.end())
             {
-                exportDevice(type, device->second, configuration);
+                exportOrRemoveDevice(type, device->second, configuration, true);
                 continue;
             }
 
@@ -328,3 +348,48 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
 
     return true;
 }
+
+void unloadOverlay(const nlohmann::json& entity)
+{
+    std::filesystem::create_directory(outputDir);
+
+    auto findExposes = entity.find("Exposes");
+    if (findExposes == entity.end() ||
+        findExposes->type() != nlohmann::json::value_t::array)
+    {
+        return;
+    }
+
+    for (const auto& configuration : *findExposes)
+    {
+        auto findStatus = configuration.find("Status");
+        // status missing is assumed to be 'okay'
+        if (findStatus != configuration.end() && *findStatus == "disabled")
+        {
+            continue;
+        }
+        auto findType = configuration.find("Type");
+        if (findType == configuration.end() ||
+            findType->type() != nlohmann::json::value_t::string)
+        {
+            continue;
+        }
+        std::string type = findType.value().get<std::string>();
+        auto device = devices::exportTemplates.find(type.c_str());
+        if (device != devices::exportTemplates.end())
+        {
+            exportOrRemoveDevice(type, device->second, configuration, false);
+            continue;
+        }
+
+        // Because many devices are intentionally not exportable,
+        // this error message is not printed in all situations.
+        // If wondering why your device not appearing, add your type to
+        // the exportTemplates array in the devices.hpp file.
+        if constexpr (debug)
+        {
+            std::cerr << "Device type " << type
+                      << " not found in export map whitelist\n";
+        }
+    }
+}
diff --git a/src/overlay.hpp b/src/overlay.hpp
index 8e818c2..343ee01 100644
--- a/src/overlay.hpp
+++ b/src/overlay.hpp
@@ -20,3 +20,4 @@
 
 void unloadAllOverlays(void);
 bool loadOverlays(const nlohmann::json& systemConfiguration);
+void unloadOverlay(const nlohmann::json& entity);
-- 
2.41.0

