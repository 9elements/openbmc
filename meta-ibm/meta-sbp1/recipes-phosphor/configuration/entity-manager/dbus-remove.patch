From 024461a4f215177eb840b4d21c67291db31d3126 Mon Sep 17 00:00:00 2001
From: Patrick Rudolph <patrick.rudolph@9elements.com>
Date: Sat, 29 Apr 2023 09:53:30 +0200
Subject: [PATCH] Overlay: Remove installed drivers when probe is false

When the FRU device is gone the probe condition is no longer true.
In that case unload the installed drivers to make sure they won't
missbehave. As with all ungraceful removals there is a chance that
the driver or other services missbehave in the meantime.

Signed-off-by: Patrick Rudolph <patrick.rudolph@9elements.com>
---
 src/entity_manager.cpp |   1 +
 src/overlay.cpp        | 100 ++++++++++++++++++++++++++++++++++-------
 src/overlay.hpp        |   1 +
 3 files changed, 85 insertions(+), 17 deletions(-)

diff --git a/src/entity_manager.cpp b/src/entity_manager.cpp
index ee08c00..ec384c0 100644
--- a/src/entity_manager.cpp
+++ b/src/entity_manager.cpp
@@ -974,6 +974,7 @@ static void pruneConfiguration(nlohmann::json& systemConfiguration,
 
     ifaces.clear();
     systemConfiguration.erase(name);
+    unloadOverlay(device);
     logDeviceRemoved(device);
 }
 
diff --git a/src/overlay.cpp b/src/overlay.cpp
index 4568699..5ad01b3 100644
--- a/src/overlay.cpp
+++ b/src/overlay.cpp
@@ -69,8 +69,9 @@ static std::string deviceDirName(uint64_t bus, uint64_t address)
     return name.str();
 }
 
-void linkMux(const std::string& muxName, size_t busIndex, size_t address,
-             const nlohmann::json::array_t& channelNames)
+void linkOrUnlinkMux(const std::string& muxName, size_t busIndex, size_t address,
+                     const nlohmann::json::array_t& channelNames,
+                     const bool create)
 {
     std::error_code ec;
     std::filesystem::path muxSymlinkDirPath(muxSymlinkDir);
@@ -110,11 +111,19 @@ void linkMux(const std::string& muxName, size_t busIndex, size_t address,
         std::filesystem::path fp("/dev" / bus.filename());
         std::filesystem::path link(linkDir / *channelName);
 
-        std::filesystem::create_symlink(fp, link, ec);
-        if (ec)
-        {
-            std::cerr << "Failure creating symlink for " << fp << " to " << link
-                      << "\n";
+        if (create) {
+            std::filesystem::create_symlink(fp, link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure creating symlink for " << fp << " to " << link
+                          << "\n";
+            }
+        } else {
+            std::filesystem::remove(link, ec);
+            if (ec)
+            {
+                std::cerr << "Failure deleteting symlink for "<< link << "\n";
+            }
         }
     }
 }
@@ -227,9 +236,10 @@ static int buildDevice(const std::string& busPath,
     return 0;
 }
 
-void exportDevice(const std::string& type,
+void exportOrRemoveDevice(const std::string& type,
                   const devices::ExportTemplate& exportTemplate,
-                  const nlohmann::json& configuration)
+                  const nlohmann::json& configuration,
+                  const bool expose)
 {
     std::string parameters = exportTemplate.parameters;
     std::string busPath = exportTemplate.busPath;
@@ -279,15 +289,24 @@ void exportDevice(const std::string& type,
                            subsituteString);
     }
 
-    int err = buildDevice(busPath, parameters, bus, address, constructor,
+    if (expose) {
+        int err = buildDevice(busPath, parameters, bus, address, constructor,
                           destructor, hasHWMonDir);
-
-    if ((err == 0) && boost::ends_with(type, "Mux") && bus && address &&
-        (channels != nullptr))
-    {
-        linkMux(name, static_cast<size_t>(*bus), static_cast<size_t>(*address),
-                *channels);
+        if ((err == 0) && boost::ends_with(type, "Mux") && bus && address &&
+            (channels != nullptr))
+        {
+            linkOrUnlinkMux(name, static_cast<size_t>(*bus), static_cast<size_t>(*address),
+                            *channels, true);
+        }
+    } else {
+        if (boost::ends_with(type, "Mux") && bus && address && channels)
+        {
+            linkOrUnlinkMux(name, static_cast<size_t>(*bus), static_cast<size_t>(*address),
+                            *channels, false);
+        }
+        deleteDevice(busPath, address, destructor);
     }
+
 }
 
 bool loadOverlays(const nlohmann::json& systemConfiguration)
@@ -321,7 +340,7 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
             auto device = devices::exportTemplates.find(type.c_str());
             if (device != devices::exportTemplates.end())
             {
-                exportDevice(type, device->second, configuration);
+                exportOrRemoveDevice(type, device->second, configuration, true);
                 continue;
             }
 
@@ -339,3 +358,50 @@ bool loadOverlays(const nlohmann::json& systemConfiguration)
 
     return true;
 }
+
+void unloadOverlay(const nlohmann::json& entity)
+{
+    std::filesystem::create_directory(outputDir);
+
+    auto findExposes = entity.find("Exposes");
+    if (findExposes == entity.end() ||
+        findExposes->type() != nlohmann::json::value_t::array)
+    {
+        return;
+    }
+
+    for (auto& configuration : *findExposes)
+    {
+        auto findStatus = configuration.find("Status");
+        // status missing is assumed to be 'okay'
+        if (findStatus != configuration.end() && *findStatus == "disabled")
+        {
+            continue;
+        }
+        auto findType = configuration.find("Type");
+        if (findType == configuration.end() ||
+            findType->type() != nlohmann::json::value_t::string)
+        {
+            continue;
+        }
+        std::string type = findType.value().get<std::string>();
+        auto device = devices::exportTemplates.find(type.c_str());
+        if (device != devices::exportTemplates.end())
+        {
+            exportOrRemoveDevice(type, device->second, configuration, false);
+            continue;
+        }
+
+        // Because many devices are intentionally not exportable,
+        // this error message is not printed in all situations.
+        // If wondering why your device not appearing, add your type to
+        // the exportTemplates array in the devices.hpp file.
+        if constexpr (debug)
+        {
+            std::cerr << "Device type " << type
+                      << " not found in export map whitelist\n";
+        }
+    }
+
+    return;
+}
diff --git a/src/overlay.hpp b/src/overlay.hpp
index 8e818c2..343ee01 100644
--- a/src/overlay.hpp
+++ b/src/overlay.hpp
@@ -20,3 +20,4 @@
 
 void unloadAllOverlays(void);
 bool loadOverlays(const nlohmann::json& systemConfiguration);
+void unloadOverlay(const nlohmann::json& entity);
-- 
2.41.0

